# C++ template

***“模板是C++中泛型编程的基础，一个模板就是一个创建类或函数的蓝图或者说公式。***

## 阅读说明

### 内容简介

- C++ template——模板与泛型编程从基础到进阶，非零基础入门向。

### 参考资料

1. 《C++ Primer》第五版。

### 格式说明

- 正常字体：普通内容。

- **加粗字体：重点内容。**

- ***粗斜字体：核心内容。***

- ~~划线文字：更正内容。~~

- > 引用文字：Note。

## 定义模板

### 函数模板

***“一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。”***

#### 实例化函数模板

- 编译器（通常）用函数实参推断出模板参数进行实例化一个特定版本的函数，这些编译器生成的版本通常被成为模板的实例。

#### 模板类型参数

- 由关键字 `typename` 或 `class` 生声明的形参为模板类型参数，该参数可以看作类型说明符。
- **类型参数可以用来指定返回类型或函数的参数类型。**

#### 非模板类型参数

- 一个非类型参数表示一个值而非一个类型，“可转化为整性的类型及指向对象或函数的指针与左值引用”声明的形参为非模板类型参数。
- ***非类型模板参数的模板实参必须是常量表达式。***
- 绑定到非类型整性参数的实参必须是一个常量表达式。由于形参限定，**不能使用字符串/浮点数等常量表达式。**
- 绑定到指针或引用非类型参数的实参必须具有静态的生命周期。**即不能使用非 `static` 的局部变量/动态对象的指针或引用。**

#### `inline` 和 `constexpr` 的函数模板

- `inline` 和`constexpr` 说明符放在模板参数列表之后，返回类型之前。

#### 编写类型无关的代码

- ***编写泛型代码的两个重要原则：***
  1. ***模板中的函数参数是 `const` 的引用。***
  2. ***函数体中的判断条件仅使用 `<` 比较运算。***
- 通过将参数设为 `const` 的引用，我们保证目标函数可以用于不能拷贝的类型，进而确保这些类型可以用目标函数来处理。
- 通过确保编写代码使只使用 `<` 比较运算符，降低了目标函数对要处理的类型的要求。
- **模板程序应该尽量减少对实参类型的要求。**

#### 模板编译

- 当编译器遇到一个模板定义时，它并不生成代码；当编译器遇到程序员实例化出模板的一个特定版本时（模板被使用），生成代码。**这一特性影响了我们如何组织代码以及错误何时被检测到。**
- 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。***因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义，即函数模板和类模板成员函数的定义通常放在头文件中。***

> 模板与头文件
>
> ***模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。***

#### 大多数编译错误在实例化期间报告

- 通常，编译器会在三个阶段针对模板报告错误：
  1. 编译模板本身时。编译器可以检测语法错误。
  2. 编译器遇到模板使用时。编译器可以检查实参数目是否正确，参数类型是否匹配，对于类模板，还可以检查用户是否提供了正确数目的模板实参。
  3. **模板实例化时。只有在这个阶段编译器才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。**
- 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是**调用者**的责任。

### 类模板

***"类模板是用来生成类的蓝图的，与函数模板的不同之处是必须在模板名后的尖括号中提供额外信息，以代替模板参数的模板实参列表。"***

#### 定义类模板

- 给出一个类模板定义的实例，该类名为 `Blob`：

  ```c++
  template <typename T>
  class Blob
  {
  public:
      typedef T value_type;
      typedef typename vector<T> size_type size_type;

      //构造函数
      Blob();
      Blob(initializer_list<T> il);

      //Blob中的元素数目
      size_type size() const { return data->size(); }
      bool empty() const {return data->empty(); }

      //添加和删除元素
      void push_back(const T &t) { data->push_back(t); }
      void pop_back();

      //移动版本
      void push_back(T &&t) { data->push_back(move(t)); }

      //元素访问
      T& back();
      T& operator[](size_type i);

  private:
      share_ptr<vector<T>> data;

      //若data[i]无效，抛出msg
      void check(size_type i,const string &msg) const;
  }
  ```

#### 实例化类模板

- 当编译器从 `Blob` 模板实例化出一个类时，它会重写 `Blob` 模板，将模板参数 `T` 的每个实例替换为给定的模板实参。对于程序员指定的每一种元素类型，编译器都生成一个不同的类。

- **一个类模板的每个实例都形成一个独立的类。即类型 `Blob<string>` 与任何其他 `Blob` 类型都没有关联，也不会对任何其他 `Blob` 类型的成员有特殊访问权限。**

#### 类模板的成员函数

- 如果在类外定义成员函数，必须以关键字 `template` 开始，后接类模板参数列表。同时要说明成员属于哪个类，从一个模板生成的类的名字中必须包含其模板实参。

- 完成 `Blob` 模板剩余的成员函数：

  ```c++
  template<typename T>
  Blob<T>::Blob(): data(make_shared<vector<T>>()) { };

  template<typename T>
  Blob<T>::Blob(initializer_list<T> il): data(make_shared<vector<T>>(il)) { };

  template<typename T>
  void Blob<T>::check(size_type i,const string &msg) const
  {
      if(i >= data->size())
          thorw std::out_of_range(msg);
  };

  template<typename T>
  T& Blob<T>::back()
  {
      check(0, "back on empty Blob.");
      return data->back();
  };

  template<typename T>
  T& Blob<T>::operator[](size_type i)
  {
      check(i, "subscript out of range.");
      return (*data)[i];
  };

  template<typename T>
  void Blob<T>::pop_back()
  {
      check(0, "pop_back on empty Blob.");
      data.pop_back();
  };
  ```

#### 类模板成员函数的实例化

- **默认情况下，对于一个实例化了的类模板，其成员只有当程序用到它时才进行实例化。**这一特性使得即使某种类型不能完全符合模板操作的要求，也能用该类型实例化类。

#### 在类代码内简化模板类名的使用

- **当处于一个类模板的作用域中时，我们就可以直接使用模板名而不指定模板实参。**即 `Blob&`  会被编译器视为 `Blob<T>&`。

#### 在类模板外使用类模板名

- **当在类模板定义其成员时，并不在类的作用域中，知道遇到类名才表示进入类的作用域。**

#### 类模板和友元

***“如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板示例，也可以只授权给特定实例。”***

##### 一对一友好关系

- 类模板与另一个（类或函数）模块间友好关系的最常见的形式是建立对应示例及其友元间的友好关系。示例：

  ```c++
  //提供两个声明式
  template <typename> class BlobPtr;
  template <typename> class Blob;

  template<typename T>
  bool operator==(const Blob<T>&, const Blob<T>&);

  template<typename T>
  class Blob
  {
      //每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符
      friend class BlobPtr<T>;
      friend bool operator==(const Blob<T>&, const Blob<T>&);

      //其它成员定义与之前相同
  }

  Blob<char> ca; // BlobPtr<char> 和 operator==<char> 都是本对象的友元
  ```

##### 通用和特定的模板友好关系

- 一个类可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元。实例：

  ```c++
  //前置声明，在将模板的一个特定实例声明为友元时要用到
  template <typename T> class Pal;

  //C是一个普通的非模板类
  class C
  {
      friend class Pal<C>; // 用类C实例化的Pal是C的一个友元
      template <typename T> friend class Pal2; // Pal2的所有实例都是C的友元
  };

  //C2是一个类模板
  template<typename T>
  class C2
  {
      friend class Pal<T>; // C2的每个实例将相同实例化的Pal声明为友元
      template <typename X> friend class Pal2; // Pal2的所有实例都是C2的每个实例的友元，必须使用与类模板本身不同的模板参数
      friend class Pal3; // Pal3是C2所有实例的友元
  };
  ```

##### 令模板自己的类型参数成为友元

- 示例：

  ```c++
  template <typename Type>
  class Bar
  {
      friend Type; // 将访问权限授予用来实例化Bar的类型，如Type将成为Bar<Type>的友元。
  }
  ```

#### 模板类型别名

- 为类模板定义一个类型别名，示例：

  ```c++
  template<typename T> using twin = pair<T, T>;
  twin<string> authors; // authors是一个pair<string, string>

  template<typename T> using partNo = pair<T, unsigned>;
  partNo<string> books; // books是一个pair<string, unsigned>
  ```

#### 类模板的 `static` 成员

- 示例代码：

  ```c++
  template <typename T>
  class Foo
  {
  public:
      static size_t count() { return ctr; }
  private:
      static size_t ctr;
  }
  ```

- 每个模板的实例都有其自己的 `static` 成员示例，即所有 `Foo<X>` 类型的对象共享同一份静态成员。

- `static` 数据成员也定义为模板，例如：

  ```c++
  template <typename T>
  size_t Foo<T>::ctr = 0; // 定义并初始化
  ```

- 可以通过类类型对象来访问一个类模板的 `static` 成员，也可以使用作用域运算符直接访问成员。通过类来访问的前提是必须引用一个特定的实例。

- `static` 成员函数也是只有在使用时才会实例化。

### 模板参数

#### 模板参数与作用域

- 一个模板参数名的可用范围在其声明之后，只模板声明或定义结束之前。
- 与任何其它名字一样，模板参数会隐藏外层作用域中生命的相同名字。
- **与大多数其它上下文不同，模板内不能重用模板参数名。如不能定义同名变量。**

#### 模板声明

- 与函数参数相同，声明中的模板参数不必与定义中相同。
- **一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。**

#### 使用类的类型成员

- 针对如下代码：

  ```c++
  T::size_type * p;
  ```

  编译器需要知道程序员是在**定义一个名为 `p` 的变量**还是**将名为 `size_type` 的 `static` 数据成员与名为 `p` 的变量相乘**。

- 默认情况下，`C++` 假定通过作用域运算符访问的名字不是类型。因此，如果程序员想使用模板类型参数的类型成员，需要使用关键字 `typename`。

#### 默认模板实参

- 其用法与函数的默认实参用法类似。同样的，**对于一个模板参数，只有当它右侧的所有参数都有默认实参是，他才可以有默认实参。**

#### 模板默认实参与类模板

- 如果一个类模板为其所有模板参数都提供了默认实参，且程序员希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。（即使程序员没有指定任何实参）。

### 成员模板

***“一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。“***

#### 非模板类的成员模板

- 这种用法一个典型的例子是，对于重载了函数调用运算符的函数对象，将其调用运算符定义为一个模板。

#### 类模板的成员模板

- 这种用法下，类和成员各有自己的、独立的模板参数。

- 当在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。示例：

  ```c++
  template<typename T>
  template<typename It>
  Blob<T>::Blob(It b, It e) { }
  ```

#### 成员模板实例化

- 为了实例化类模板的成员模板，必须同时提供类和函数模板的实参。

#### 控制实例化

- 因为模板被使用时才会进行实例化，所以相同的实例可能出现在多个对象文件中。而多个文件中实例化相同模板的额外开销可能非常严重。**可以通过显示实例化避免这种开销**。一个显式实例化具有如下形式：

  ```c++
  // declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参
  extern template declaration; // 实例化声明
  template declaration;        // 实例化定义
  ```

- 一段示例代码：

  ```c++
  // test.c
  extern template class Blob<string>;
  Blob<string> s1; // 实例化出现在其他位置

  Blob<int> i1; // 在本文件中实例化
  ```

- **对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。**

- 一个类模板的实例化定义会实例化该类模板的所有成员。因为**对于普通实例化来说，实例化时就决定了调用哪一个成员，而显式实例化时并不知道调用了哪些成员**。所以必须确保显式实例化类模板的类型，能够用于模板的所有成员。

### 效率与灵活性

- 考虑 `share_ptr`  和 `unique_ptr` 二者在重载默认删除器方式上的差别。

  1. `share_ptr` 在运行时绑定删除器，可以随时改变其删除器的类型。假定它管理的指针保存在一个成员 `p` 中，删除器是通过一个名为 `del` 的成员来访问的，则 `share_ptr` 的析构函数中会有类似如下的语句：

     ```c++
     // del 的值只有在运行时才知道；通过一个指针来调用它
     del ? del(p) : delete p; // del(p)需要运行时跳转到 del 的地址
     ```

     由于删除器是间接保存的，调用 `del(p)` 需要一次运行时的跳转操作，转到 `del` 保存的地址来执行对应的代码。

  2. `unique_ptr` 在编译器绑定删除器，删除器的类型时类类型的一部分。因而其析构函数包含类似如下的代码：

     ```c++
     // del 在编译时绑定；直接调用实例化的删除器
     del(p);
     ```

- **通过在编译时绑定删除器，可以避免间接调用删除器的运行时开销；通过在运行时绑定删除器，使用户重载删除器更为方便。**

## 模板实参推断

***“从函数实参来确定模板实参的过程被称为模板实参推断。在这个过程中，编译器使用函数中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配。”***

### 类型转换与模板类型参数

#### 模板类型转换规则

- 与非模板函数一样，传递给模函数模板的实参被用来初始化函数的形参。如果函数形参的类型使用了模板类型参数，则会采用特殊的初始化规则，**只有很有限的几种类型转换会自动应用于这些实参。编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。**

  1. 顶层 `const`，即 `const` 指针无论在形参还是在实参中都会被忽略。
  2. 非 `const` 对象的引用或指针可以传递给 `const` 的引用或指针的形参。
  3. 如果函数形参不是以用类型，则数组实参可以转换为一个指向其首元素的指针，函数实参可以转换为一个该函数类型的指针。
  4. 其他类型转换都不能应用于函数模板。

- 一段示例代码：

  ```c++
  template <typename T> T fobj(T, T)                // 实参被拷贝
  template <typename T> T fref(const T&, const T&); // 传递引用

  string s1("a value");
  const string s2("other value");
  fobj(s1, s2); // s2 的 const 被忽略
  fref(s1, s2); // s1 被转换为 const

  int a[10], b[20];
  fobj(a, b); // a, b 被转换为 int*
  fref(a, b); // 错误，数组大小不同，类型不匹配
  ```

#### 使用相同参数类型的函数形参

- 如果一个模板类型参数被用作多个函数形参的类型，则要求传递给这些形参的实参必须具有同一类型。如果推断出的类型不匹配，调用就是错误的。
- 如果希望对函数实参进行正常的类型转换，允许程序员提供不同的实参，可以将模板定义为两个乃至多个类型参数。

#### 正常类型转换应用于普通函数实参

- 如果模板函数的参数类型不是模板参数，则对实参进行正常的类型转换。

### 函数模板显式实参

#### 指定显式模板实参

- 当函数返回类型与参数列表中任何类型都不相同时，考虑如下代码：

  ```c++
  template <typename T1, typename T2, typename T3>
  T1 sum(T2, T3);
  // 编译器无法推断T1,因为它未出现在函数参数列表中。
  ```

  为了解决类似这样的问题，每次调用 `sum` 时必须提为 `T1` 提供一个显式模板实参。

  ```c++
  auto val3 = sum<long long>(i, lng); // long long sum(int, long)
  // T1是显式指定的。
  ```

- 显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，以此类推。**只有尾部（最右）参数的显示模板实参才可以忽略，前提是它们可以从函数参数推断出来。**

#### 正常类型转换应用于显式指定的实参

- 对于模板类型参数已经显式指定了的函数实参，孕育进行正常的类型转换。示例：

  ```c++
  long lng;
  compare(lng, 1024);       // 错误：模板参数不匹配
  compare<long>(lng, 1024); // 正确：实例化compare(long, long)
  compatr<int>(lng, 1024);  // 正确：实例化compare(int, int)
  ```

### 尾置返回类型与类型转换

#### 尾置返回类型的应用场景及方法

- 当未明确返回类型时，可以采用此种方法。参考如下代码：

  ```c++
  // 尾置返回允许我们在参数列表之后声明返回类型
  template <typename It>
  auto fun (It beg, It end) -> decltype(*beg) // decltype作用一个左值身上时，得到的是其引用
  {
      // ...
      return *beg; // 返回序列中一个元素的引用
  }
  ```

#### 进行类型转换的标准库模板类

- 针对上例中，使用 `decltype` 可以获得 `beg` 元素类型的引用类型，而 `remove_reference<decltype(*beg)>::type` 能够脱去引用，获得元素本身的类型。示例代码：

  ```c++
  // 尾置返回允许我们在参数列表之后声明返回类型
  template <typename It>
  auto fun2 (It beg, It end) -> typename remove_reference<decltype(*beg)>::type // typename关键字声明后面的type表示一个类型
  {
      // ...
      return *beg; // 返回序列中一个元素的引用
  }
  ```

### 函数指针和实参推断

- 当用函数模板初始化一个函数指针或为一个函数指针复制时，编译器会使用指针的类型来推断模板实参。示例代码：

  ```c++
  template <typename T>
  int compare(const T&, const T&);
  int (*pf1)(const int&, const int&) = compare;
  ```

- 如果不能从函数指针类型确定模板实参，即不能确定实参的唯一实例化版本，此调用将编译失败。此时需要显示指出实例化那个版本。如当出现函数重载时，示例代码：

  ```c++
  void fun(int(*)(const string&, const string&));
  void fun(int(*)(const int&, const int&));
  fun(compare); // error

  // 可以通过显示模板实参来消除 fun 调用的歧义
  fun(compare<int>); // 传递compare(const int&, const int&)
  ```

- **当参数是一个函数模板实例的地址时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型或值。**

### 模板实参推断和引用

***“编译器会应用正常的引用绑定规则；`const` 是底层的，不是顶层的。”***

#### 从左值引用参数推断类型

- 当一个函数参数是模板类型参数的一个左值引用时，只能传递给它一个左值。实参如果是 `const` 的，则模板参数会被推断为 `const` 类型。示例代码：

  ```c++
  temlate <typename T>
  void f1(T&); // 实参必须是一个左值
  // 对 f1 的调用使用实参所引用的类型作为模板参数类型
  f1(i);  // i是一个int，模板参数T是int
  f1(ci); // ci是一个const int，模板参数T是const int
  f1(5);  // 错误：传递给一个&参数的实参必须是一个左值
  ```

- 当一个函数参数是模板类型参数的 `const` 引用时，可以传递给它任何类型的实参。实参如果是 `const` 的，模板参数也不会被推断为 `const` 的，因为 `const` 已经是函数参数类型的一部分，而不是模板参数类型的一部分。示例代码

  ```c++
  temlate <typename T>
  void f2(const T&); // 可以接受一个右值
  // f2中的参数是const&，实参中的const是无关的
  // 在每个调用中，f2的函数参数都被推断为const int&
  f1(i);  // i是一个int，模板参数T是int
  f1(ci); // ci是一个const int，但模板参数T是const int
  f1(5);  // 一个const&参数可以绑定到一个右值，T是int
  ```

#### 从右值引用参数推断类型

- 当一个函数参数是模板类型参数的右值引用时，可以传递给它一个右值。其类型推断过程类似普通左值引用函数参数的推断过程（由实参推断出的类型为被引用的类型）。示例代码：

  ```c++
  temlate <typename T>
  void f3(T&&);
  f3(42); // 实参是一个int类型的右值，模板参数T是int
  ```

#### 引用折叠和右值引用参数

- 两个例外的引用绑定规则：

  1. 当一个左值（如 `i`）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如 `T&&`）时，编译器推断模板类型参数为实参的左值引用类型。如调用 `f3(i)` 时，编译器推断 `T` 的类型为 `int&`。
  2. 由于通过类型别名或通过模板类型参数可以间接定义引用的引用，在这种情况下，如果间接创建一个引用的引用，则这些引用形成了“折叠”。**引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数**，其折叠规则：
     - `X& &` 、 `X& &&` 、`x&& &` 都折叠成 `X&`。
     - `X&& &&` 折叠成 `X&&`。

- 结合上述两规则，意味着可以对一个左值调用 `f3`。当一个左值传递给 `f3` 的右值引用函数参数时，编译器推断 `T` 为一个做左值引用类型：

  ```c++
  f3(i);  // 实参是一个左值，模板参数T是一个int
  f3(ci); // 实参是一个左值，模板参数T是一个const int
  ```

  而折叠规则告诉我们函数参数 `T&&` 折叠为一个左值引用类型，例如：

  ```c++
  void f3<int&>(int& &&); // 无效代码，仅用于演示

  // 由于引用折叠，即使f3的函数参数形式是一个右值引用，此调用也会用一个左值引用类型实例化f3
  void f3<int&>(int &); // 实际的效果
  ```

- 两个规则导致的两个重要结果：

  1. **如果一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值；且**
  2. **如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数。**

- 综上：***如果一个函数参数是指模板参数类型的右值引用（如 `T&&`），则可以传递给它任意类型的是实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（`T&`）。***

#### 编写接受右值引用参数的模板函数

- 右值引用通常用于两种情况：模板转发其实参或模板被重载。

- 使用右值引用的函数模板通常使用的重载方式：

  ```c++
  template <typename T> void f(T&&);      // 绑定到非const右值
  template <typename T> void f(const T&); // 左值和const右值
  ```

### 理解 `std::move`

#### `std::move` 如何定义

- 标准可如下定义 `move`：

  ```c++
  // 可以传递给move左值及右值
  template <typename T>
  typename remove_reference<T>::type&& move(T&& t)
  {
      return static_cast<typename remove_reference<T>::type&&>(t);
  }
  ```

#### `std::move` 如何工作

- 考虑如下代码中 `move` 的工作过程：

  ```c++
  s = std::move(string("C++ template is a game!"));
  ```

  1. 推断出 `T` 的类型为 `string`。
  2. `remove_reference` 用 `string` 实例化。
  3. `remove_reference` 的 `type` 成员是 `string`。
  4. `move` 的返回类型是 `string &&`。
  5. `move` 的参数 `t` 的类型为 `string&&`。

  因此，实例化 `move<string>` 即 `string&& move(string &&t)`。

- 考虑如下代码中 `move` 的工作过程：

  ```c++
  string s1("C++ template is a game!");
  s = std::move(s1);
  ```

  1. 推断出 `T` 的类型为 `string&`。
  2. `remove_reference` 用 `string&` 实例化。
  3. `remove_reference` 的 `type&` 成员是 `string`。
  4. `move` 的返回类型是 `string &&`。
  5. `move` 的参数 `t` 实例化为 `string& &&`，折叠为 `string&`。

  因此，实例化 `move<string&>` 即 `string&& move(string &t)`。

#### 从左值 `static_cast` 到右值

- 针对右值引用的特许规则：**虽然不能隐式地将一个左值转换为右值引用，但可以用 `static_cast` 显式地将一个左值转换为一个右值引用。**

### 转发

- 有时候函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，需要保持被转发实参的所有性质，包括实参类型是否是 `const` 及实参是左值还是右值。了解下面一个较为复杂的例子。

#### 一段并不完善的代码

- 考虑如下一段代码：

  ```c++
  // flip1接受一个可调用对象和另外两个参数的模板
  // 对“翻转”的参数调用给定的可调用对象
  // flip1是一个不完整的实现：const属性和引用丢失了
  template<typename F, typename T1, typename T2>
  void flip1(F f, T1 t1, T2 t2)
  {
    f(t2, t1);
  }
  ```
  
  这个函数一般情况下工作得很好，但当希望用它调用一个接受引用参数的函数时会出现问题：
  
  ```c++
  void f(int v1, int &v2)
  {
    cout << v1 << " " << ++v2 << endl;
  }
  ```
  
  这段代码中，`f` 改变了绑定到 `v2` 实参的值。但是如果通过 `flip1` 调用 `f`，`f` 所做的改变就不会影响最早的实参：
  
  ```c++
  f(20, i);        // f改变了实参i
  flip1(f, j, 20); // 通过flip1调用f不会改变j
  ```
  
  问题在于：**`j` 被传递给 `flip1` 的参数 `t1`，此参数是一个普通的、非引用的类型 `int`，而非 `int&`。因此 `flip1` 被实例化为：**
  
  ```c++
  void flip1(void(fun)(int, int&), int t1, int t2);
  ```
  
  **`j` 的值被拷贝到 `t1` 中，`f` 中的引用参数被绑定到 `t1`，而非 `j`，从而其改变不会影响 `j`。**

#### 定义能保持类型信息的函数参数

- 为了使其参数能保持给定实参的“左值性”，以及更进一步的参数 `const` 属性，需要重写函数。

- **通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数（无论是左值还是右值）使得我们可以保持 `const` 属性，因为在引用类型中的 `const` 是底层的。**

- **通过将函数参数定义为 `T1&&` 和 `T2&&`，根据引用折叠的规则就可以保持反转实参的左值/右值属性。**

  ```c++
  template<typename F, typename T1, typename T2>
  void flip2(F f, T1 &&t1, T2 &&t2)
  {
    f(t2, t1);
  }
  ```

  解读：**如果调用 `flip2(f, j, 20)`，将传递给参数 `t1` 一个左值 `j`。但是在 `flip2` 中推断 `T1` 的类型为 `int&`，意味着 `t1` 的类型会折叠为 `int&`。由于是引用类型，`t1` 被绑定到 `j` 上。当 `flip2` 调用 `f` 时，`f` 中的引用参数 `v2`，被绑定到 `t1`，也就是被绑定到 `j`。当 `f` 递增 `v2` 时，同时改变了 `j` 的值。**

  即：***如果一个函数参数时指向模板类型参数的右值引用（如 `T&&`），它对应的实参的 `const` 属性和左值/右值属性将得到保持。***

- 但是，这个版本的 `flip2` 不能用于接受右值引用参数的函数。示例代码：

  ```c++
  void g(int &&i, int &j)
  {
      cout << i << " " << j << endl;
  }
  flip2(g, i, 20); // 错误：不能从一个左值实例化int&&
  ```

#### 在调用中使用 `std::forward` 保持类型信息

- `forward` 可以保持原始实参的类型。它必须通过显示模板实参来调用，并返回该模板实参类型的右值引用。即，`forward<T>` 的返回类型是 `T&&`。

- 通过如下代码考虑 `forward` 的原理：

  ```c++
  template <typename T>
  void testFun(T &&arg)
  {
      finalFun(std::forward<T>(arg));
  }
  ```

  1. 由于 `arg` 是一个模板类型参数的右值引用，则 `T` 被推断出表示为传递给 `arg` 的实参的所有类型信息。进而用 `T` 作为 `forward` 的显示模板参数类型。
  2. **如果实参是一个右值，则 `T` 是一个普通非引用类型，`forward<T>` 将返回 `T&&`。**
  3. **如果实参是一个左值，则通过引用折叠，`T` 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对该返回类型进行折叠，将返回一个左值引用类型。**

  即：***当用于一个指向模板参数类型的右值引用函数参数（T&&）时，`forward` 会保持实参类型的所有细节。***

- 最终版本的 `flip`：

  ```c++
  template <typename F, typename T1, typename T2>
  void flip_over(F f, T1 &&t1, T2 &&t2)
  {
      f(std::forward<T2>(t2), std:forward<T1>(t1));
  }
  
  flip(g, i, 20); // i以int&类型传递给g，20以int&&类型传递给g。
  ```

## 重载与模板

### 重载函数模板时的函数匹配规则

1. 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。
2. 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。
3. 与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数调用的类型是非常有限的。
4. 与往常一样，如果恰好有一个函数提供比任何其他函数都更好的匹配，则选择此函数。如果有多个函数提供同样好的匹配，则：
   - 如果同样好的函数只有一个是非模板函数，则选择此函数。
   - 如果同样好的函数中没用非模板函数，而有多个模板函数，且其中一个模板函数比其他模板更特例化，则选择此函数。
   - 否则，此调用有歧义。

### 重载模板实例

#### 编写重载模板

- 考虑如下两个重载模板：

  ```c++
  template <typename T>
  string debug_rep(const T &t)
  {
      // ...
  }
  
  template <typename T>
  string debug_rep(T *t)
  {
      // ...
  }
  
  string s("hi!");
  debug_rep(s); // 只能调用第一个版本，因为编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板
  
  debug_rep(&s); // 这样调用，两个模板都声称可行实例：
  // debug_rep(const string*&)，第一个版本实例化而来，T被绑定到string*
  // debug_rep(string*)，第二个版本实例化而来，T被绑定到string
  ```

  此时，因为第一个版本第一个版本的实例需要进行普通指针到 `const` 指针的转换，正常函数匹配规则告诉我们应选择第二个模板，编译器也确实选择了这个版本。

#### 多个可行模板

- 考虑下面的调用：

  ```c++
  const string *sp = &s;
  cout << debug_rep(sp) << endl; // 两个模板都可行，并且都是精确匹配
  // debug_rep(const string*&)，第一个版本实例化而来，T被绑定到string*
  // debug_rep(const string*)，第二个版本实例化而来，T被绑定到const string
  ```

  此时，正常函数匹配规则无法区分这两个函数。但是根据重载函数模板的特殊规则，此调用被解析为第二个版本，即更特例化的版本。

  如果没有这条规则，将无法对一个 `const` 的指针调用指针版本的 `debug_rep`，因为这样的调用永远是有歧义的。问题在于模板 `debug_rep(const T&)` 本质上可以用于任何类型，包括指针类型。此模板比 `debug_rep(T*)` 更通用，后者只能用于指针类型。

#### 非模板和函数重载

- 考虑一个普通非模板的 `debug_rep`：

  ```c++
  string debug_rep(const string &s)
  {
      // ...
  }
  
  string s("hi!");
  cout << debug_rep(s) << endl; // 有两个同样好的可行函数
  // debug_rep<string>(const string&)，第一个模板，T被绑定到string
  // debug_rep(const string&)，普通非模板函数
  ```

  此时，一个非函数模板与一个函数模板提供同样好的匹配，根据类似“选择最特例化”的思想，编译器会选择非模板版本。

#### 重载模板与类型转换

- 考虑如下调用：

  ```c++
  cout << debug_rep("hi!") << endl; // 本调用中三个debug_rep版本都是可行的
  // debug_rep(const T&)，T被绑定到char[10]
  // debug_rep(T*)，T被绑定到const char
  // debug_rep(const string&)，要求从const char*到string的类型转换
  ```

  对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次（许可的）数组到指针的转换。而对于函数匹配来说，这种转换被认为是精确匹配。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配那么好，所以两个模板成为可能调用的函数。和之前一样，T*版本更加特例化，编译器会选择它。

#### 缺少声明可能导致程序行为异常

- 在定义任何函数之前，记得先声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。示例代码：

  ```c++
  template <typename T> string debug_rep(const T &t);
  template <typename T> string debug_rep(T *pt);
  
  // 为了使debug_rep(char&)的定义正确工作，下面的声明必须在作用域中
  string debug_rep(const string &);
  
  string debug_rep(char *p)
  {
      return debug_rep(string(p));
      // 如果接受一个const string&的版本的生命不在作用域中
      // 返回语句将调用debug_rep(const T&)的T实例化为string的版本
  }
  ```

## 可变参数模板

### 可变参数模板的基本概念

- 一个**可变参数模板**就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为**参数包**。存在两种参数包：**模板参数包**，表示零个或多个模板参数；**函数参数包**，表示零个或多个函数参数。

- 用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，`class ...` 或 `typename ...` 指出接下来的参数表示零个或多个类型的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。示例代码：

  ```c++
  template <typename T, typename... Args>
  void foo(const T &t, const Args& rest);
  // Args是一个模板参数包；rest是一个函数参数包
  // Args表示零个或多个模板类型参数
  // rest表示零个或多个函数参数
  ```

- 对参数包使用 `sizeof`  运算符，可以知道参数包中含有多少元素。示例代码：

  ```c++
  template <ypename... Args>
  void g(Args ... args)
  {
      cout << sizeof...(Args) << endl; // 类型参数的数目
      cout << sizeof...(args) << endl; // 函数参数的数目
  }
  ```

### 编写可变参数函数模板

- 考虑一个可变参数函数模板的典型例子，一个名为 `print` 的函数，它在一个给定流上打印给定实参列表的内容。

- 可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。`print` 函数也是这样的模式，每次递归调用将第二个实参打印到第一个实参表示的流中。为了终止递归，还需要定义一个非可变参数的 `print` 函数，它接受一个流和一个对象。示例代码：

  ```c++
  // 用来终止递归并打印最后一个元素的函数
  // 此函数必须在可变参数版本的print定义之前声明
  template <typename T>
  ostream &print(ostream &os, const T &t)
  {
      return os << t;
  }

  // 包中除了最后一个元素之外的其他元素都会调用这个版本的print
  template <typename T, typename... Args>
  ostream &print(ostream &os, const T &t, const Args&... rest)
  {
      os << t << ", ";
      return print(os, rest...); // 递归调用，rest中的第一个实参被绑定到t，剩余实参形成下一个print的调用的参数包
  }
  ```

  第一个版本的 `print` 负责终止递归并打印出初始调用中的最后一个实参。第二个版本的 `print` 是可变参数版本，它打印绑定到 `t` 的实参，并调用自身来打印函数参数包中的剩余值。递归调用过程举例：

  |                      调用                      |  t   | rest... |
  | :--------------------------------------------: | :--: | :-----: |
  |            `print(cout, i, s, 20)`             | `i`  | `s, 20` |
  |              `print(cout, s, 20)`              | `s`  |  `20`   |
  | `print(cout, 20)` 调用非可变参数版本的 `print` | `20` |    /    |

  对于最后一次调用非可变参数版本的 `print`，两个 `print` 函数提供同样好的匹配。但是非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。

### 包扩展

#### 包扩展的行为

- 对于一个参数包，除了获取其大小外，**能对它做的唯一的事情就是扩展它**。当扩展一个包时，**我们还要提供用于每个扩展元素的模式**。***扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表***。通过在模式右边放一个省略号来触发扩展操作。对于之前的 `print` 函数，包含两个扩展：

  ```c++
  template <typename T, typename... Args> // 扩展Args
  ostream &print(ostream &os, const T &t, const Args&... rest)
  {
      os << t << ", ";
      return print(os, rest...); // 扩展rest
  }
  ```

  1. 第一个扩展操作扩展模板参数包 `Args`，为 `print` 生成函数参数列表。编译器将模式 `cosnt Arg&` 应用到模板参数包 `Args` 中的每个元素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 `const type&`，例如：

     ```c++
     print(cout, i, s, 20); // 包中有两个参数，被实例化为：
     ostream& print(ostream&, const int&, const string&, const int&);
     ```

  2. 第二个扩展操作出现在对 `print` 的递归调用中。此情况下，模式是函数参数包的名字。此模式扩展出一个由包中元素组成的逗号分隔的列表。故这个调用等价于：

     ```c++
     print(os, s, 20);
     ```

#### 理解包扩展

- 一条核心的规则是，***扩展中的模式会独立地应用与包中的每个元素***。

- 考虑这样一个例子：函数 `errorMsg` 对其每个实参调用 `debug_rep`，然后调用 `print` 打印结果 `string`。示例代码：

  ```c++
  template <typename... Args>
  ostream &errorMsg(ostream &os, const Args&... rest)
  {
      return print(os, debug_rep(rest)...);
  }
  ```

  这个 `print` 调用使用了模式 `debug_reg(rest)`，此模式表示对函数参数包 `rest` 中的每个元素调用 `debug_rep`。扩展结果是一个逗号分隔的 `debug_reo` 调用列表。即：

  ```c++
  errorMsg(cerr, fcnName, code.num(), otherData, "other", item);
  // 等价于
  print(cerr, debug_rep(fcnName), debug_rep(code.num()), debug_rep(otherData), debug_rep("other"), debug_rep(item));
  ```

  与之相对，下面的模式会编译失败：

  ```c++
  // 将包传递给debug_rep
  print(os, debug(rest...)); // 错误：此调用无匹配函数
  // 等价于
  print(cerr, debug_rep(fcnName, code.num(), otherData, "other", item));
  ```

  `debug_rep` 函数是不可变参数的，而且没有哪个 `debug_rep` 版本接受五个参数。

### 转发参数包

- 可变参数函数通常将它们的参数转发给其他函数。这里推荐一个建议的使用形式：

  ```c++
  // fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用
  template <typename... Args>
  void fun(Args&... args) // 将Args扩展为一个右值引用的列表
  {
      // work的实参既扩展Args又扩展args
      work(std::forward<Args>(args)...)
  }
  ```

## 模板特例化

***“一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型 。”***

### 定义函数模板特例化

- 当特例化一个函数模板时，**必须为元模板中的每个模板参数都提供实参**。通过 `template<>` 这样的形式指出正在实例化一个模板，将为原模板的所有模板参数提供实参。示例代码：

  ```c++
  // compare的特殊版本，处理字符数组的指针
  template <>
  int compare(const char* const &p1, const char* const &p1)
  {
      return strcmp(p1, p2);
  }
  ```

  特例化版本的重难点是函数参数类型。当定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。像是在本例中，`T` 为 `const char*`，函数要求一个指向此类型 `const` 版本的引用。而指针类型的 `const` 版本是一个常量指针，故声明函数参数为 `const char* const &p1`。

### 函数重载与模板特例化

- 当定义函数模板的特例化版本时，本质上是接管了编译器的工作。即，**为原模板的一个特殊实例提供了定义**。关键在于区分：**一个特例化版本本质上是实例化一个模板，而非函数名的一个重载版本**。因此，**特例化不影响函数匹配**。
- 使用建议：**模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本**。

### 类模板特例化

- 类模板特例化的方法与函数模板特例化方法类似。也要注意：**为了让某一类型 `type` 的用户能使用模板 `template` 的特例化版本，应该在 `type` 的头文件中定义该特例化版本。另外，如果 `template<type>` 这一特例化版本要求使用 `type` 的私有成员，则需要将它声明为 `type` 的友元。**。

### 类模板部分特例化

- 与函数模板不同，类模板的特例化不必为所有模板参数提供实参，因此它可以进行部分特例化。我们可以只指定一部份而非所有模板参数，或是参数的一部分而非全部特性。**一个类模板的部分特例化本身还是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。**
- 部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版本。部分特例化版本的模板参数可以和原始模板数目不同，或是类型不同。

### 特例化成员不是类

- 我们可以指特例化特定成员函数而不是特例化整个模板。示例代码：

  ```c++
  template <typename T>
  class Foo
  {
      // 其它成员函数
      void Bar() { ... };
      // 其它成员函数
  };
  
  template<>
  void Foo<int>::Bar()
  {
      // ...
  }
  ```

  当用 `int` 使用 `Foo`时，`Bar` 之外的成员像往常一样进行实例化，而 `Foo<int>` 的成员 `Bar` 会使用我们定义的特例化版本。

## 小结

- 模板时 `C++` 语言与众不同的特性，也是标准库的基础。一个模板就是一个编译器用来生成特定类类型或函数的蓝图。生成特定类或函数的过程成为实例化。我们只编写一次模板，就可以将其用于多种类型的值，编译器会为每种类型和值进行模板实例化。
- 我们既可以定义函数模板，也可以定义类模板。标准库算法都是函数模板，标准库容器都是类模板。
- 显示模板实参允许我们固定一个或多个模板参数的类型或值。对于指定了显示模板实参的模板参数，可以应用正常的类型转换。
- 一个模板特例化就是一个用户提供的模板实例，它将一个或多个模板参数绑定到特定类型或值上。当我们不能（或不希望）将模板定义用于某些特定类型时，特例化非常有用。
- 最新 `C++` 标准的一个主要部分是可变参数模板。一个可变参数模板可以接受数目和类型可变的参数。可变参数模板允许我们编写像容器的 `emplace` 成员和标准库 `make_shared` 函数这样的函数，实现将实参传递给对象的构造函数。

## 术语表

### 1.类模板

- 模板定义，可从它实例化出特定的类。类模板的定义以关键字 `template` 开始，后面跟尖括号对 `<` 和 `>`，其内为一个用逗号分隔的一个或多个模板参数的列表，随后是类的定义。

### 2.默认模板实参

- 一个类型或一个值。当用户未提供对应模板实参时，模板会使用它。

### 3.显式实例化

- 一个声明，为所有模板参数提供了显式实参，用来指导实例化过程。如果声明是 `extern` 的，模板将不会被实例化；否则，模板将利用指定的实参实例化。对每个 `extern` 模板声明，在程序中某处必须有一个非 `extern` 的显示实例化。

### 4.显示模板实参

- 在一个函数调用中或定义模板类类型时，由用户提供的模板实参。显示模板实参在紧跟在模板名的尖括号对中给出。

### 5.函数参数包

- 表示零个或多个函数参数的参数包。

### 6.函数模板

- 模板定义，可从它实例化出特定函数。函数模板的定义以关键字 `template` 开始，后面跟尖括号对 `<` 和 `>`，其内为一个用逗号分隔的一个或多个模板参数的列表，随后是函数的定义。

### 7.实例化

- 编译器处理过程，用实际的模板实参来生成模板的一个特殊实例，其中参数被替换为对应的实参。当函数模板被调用时，会自动根据传递给它的实参来实例化。而使用类模板时，则需要我们提供显示模板实参。

### 8.实例

- 编译器从模板生成的类或函数。

### 9.成员模板

- 本身是模板的成员函数。成员模板不能是虚函数。

### 10.非类型参数

- 表示值的模板参数。非类型模板参数的实参必须是常量表达式。

### 11.包扩展

- 处理过程，将一个参数包替换为其中元素的列表。

### 12.参数包

- 表示零个或多个参数的模板或函数参数。

### 13.部分特例化

- 类模板的一个版本，其中制定了某些但不是所有模板参数，或是一个或多个参数的属性未被未被完全指定。

### 14.模式

- 定义了扩展后参数包中每个元素的形式。

### 15.模板实参

- 用来实例化模板参数的类型或值。

### 16.模板实参推断

- 编译器确定实例化哪个函数模板的过程。编译器检查那些使用模板参数的实参的类型，将这些类型或值绑定到模板参数，来自动实例化一个函数版本。

### 17.模板参数

- 在模板参数列表中指定的名字，可在模板定义内部使用。模板参数可以是类型参数，也可以是非类型参数。为了使用一个类模板，我们必须为每个模板参数提供显式实参。编译器使用这些类型或值实例化出一个类版本，其中所有用到模板参数的地方都被替换为实际的实参。当使用一个函数模板时，编译器使用调用中的函数实参推断模板实参，并使用推断出的模板实参实例化出一个特定的函数。

### 18.模板参数列表

- 用逗号分割的参数列表，用于模板的定义或声明中。每个参数可以是一个类型参数，也可以是一个非类型参数。

### 19.模板参数包

- 表示零个或多个模板参数的参数包。

### 20.模板特例化

- 类模板、类模板的成员或函数模板的重定义，其中指定了某些（或全部）模板参数。模板特例化版本必须出现在原模板的声明之后，必须出现在任何利用特殊实参来使用模板的代码之前。一个函数模板中的每个模板参数都必须完全特例化。

### 21.类型参数

- 模板参数列表中的名字，用来表示类型。类型参数在关键字 `typename` 或 `class` 之后指定。

### 22.类型转换

- 由标准库定义的类模板，可将给定的模板类型参数转换为一个相关类型。

### 23.可变参数模板

- 接受可变数目模板实参的模板。模板参数包用省略号指定（如 `class...` 、`typename...`)。
