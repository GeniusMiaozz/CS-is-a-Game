# C/C++复习总结

## 说明

- 本文为个人 `C/C++` 复习内容的简要总结，仅针对应届生校招的难度。

- 文中具体参考内容的出处均已注明并标注链接。

  - 主要参考网站包括：

  1. [菜鸟教程 C教程](https://www.runoob.com/cprogramming/c-tutorial.html)
  2. [菜鸟教程 C++教程](https://www.runoob.com/cplusplus/cpp-tutorial.html)
  3. [牛客网 C++面试宝典](https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1)
  4. [Github开源项目 C++那点事](https://light-city.club/sc/)

  - 主要参考书籍包括：

  1. Effective C++(第三版)

## 基础数据/结构/类型

### 常量

- 整数常量：前缀 `0X` 或 `0x` 代表十六进制，前缀 `0` 表示八进制，不带前缀默认为十进制；后缀 `U/u` 代表无符号整数，`L/l` 代表长整数。

- 字符常量：`\a` 为警报铃声，`\b` 为退格键，`\f` 为换页符，`\v` 为垂直制表符，`\ooo` 为一到三位的八进制数，`\xhhh` ......为一道多个数字的十六进制数。

- 对于常量的定义，多推荐为大写字母的形式。

### 内置类型

- 各种变量类型在内存中存储值时需要占用的位数：

    | 类型 | 字节数 |
    | :-: | :-: |
    | `char` | `1` |
    | `int` | `4` |
    | `short int` | `2` |
    | `long int` | `4` |
    | `float` | `4` |
    | `double` | `8` |
    | `long double` | `16` |

### 局部变量与全局变量

- 当局部变量被定义时，系统不会对其初始化。定义全局变量时，会自动初始化为下列值：

    | 数据类型 | 初始化默认值 |
    | :-: | :-: |
    | `int` | `0` |
    | `float` | `0` |
    | `double` | `0` |
    | `char` | `'\0'` |
    | `pointer` | `NULL` |

### 浮点数

- 浮点数的比较不能直接使用 `'='` 进行判断，可以使用减法，当差值在精度允许范围内（比如 `0.0000001`）即可视为两个浮点数相等。

### 字符串

- 对于`char str1[]` 和 `char str2[]`，如果二者赋值相同，由于 `str1` 和 `str2` 初始地址不同，`str1 != str2`；对于`char *str1` 和 `char *str2`，如果二者赋值相同，相当于二者指向内存中同一段地址，`str1 = str2`。

### 存储类

- 存储类定义 `C/C++` 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。

- 存储类主要包含四种：`auto`、`register`、`static`、`extern`。

### 位域

- 位域在本质上就是一种结构体类型，只不过其成员按二进制中的每一位分配。

## 内存

### 指针 & 引用

#### 指针

- `32` 位机器一个指针占 `4`字节空间，`64` 位机器一个指针占 `8` 字节空间。

- 野指针是指向一个已删除的对象或者未申请访问受限内存区域的指针。

- 数组做为函数的参数传递时，自动退化为同类型指针，指向数组的第一个元素。

- 指针函数：返回值是某一类型指针的函数，如 `int *fun()`，该函数返回值为一个地址；函数指针：指向某一函数的指针变量可以调用函数，如 `int (*fun)() = & fun1`。

- 指针数组：一个元素均为某一类型指针的的数组，如 `int *p[10]`，该数组包含十个 `int` 类型指针的元素；数组指针：指向数组某个元素地址的指针，如 `int (*p) [10]`，`p`指向数组的首地址（首个元素的地址）。

- 智能指针：主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

#### 引用

- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。
- 引用一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率。

#### 指针与引用和异同点

- 区别总结

    |                           指针                           |                             引用                             |
    | :------------------------------------------------------: | :----------------------------------------------------------: |
    | 指针是一个变量，该变量存储的是一个地址，有自己的一块空间 |                       引用只是一个别名                       |
    |          `sizeof(指针)` 得到的是指针本身的大小           |           `sizeof(引用)` 得到的是被引用对象的大小            |
    |                指针可以被初始化为 `NULL`                 |          引用必须被初始化且必须是一个已有对象的引用          |
    |   作为参数传递时，指针需要被解引用才可以对对象进行操作   |           直接对引用的修改都会改变引用所指向的对象           |
    |                    可以有 `const`指针                    |                      没有 `const` 引用                       |
    |               指针在使用中可以指向其它对象               |             引用只能是一个对象的引用，不能被改变             |
    |               指针可以有多级指针（`**p`）                |                         引用只有一级                         |
    |          指针使用 `++` 运算符的意义是地址加”一”          |      引用使用 `++` 运算符的意义是被引用对象本身值加”一”      |
    |         动态内存分配的对象或者内存，必须使用指针         | 动态内存分配的对象或者内存，不可使用引用，否则可能引起内存泄漏 |

- 指针与引用可以参考如下代码：

    ```C++
    int a,b,*p,&r=a;//正确
    r = 3;//正确：等价于a=3
    int &rr;//出错：引用必须初始化
    p = &a;//正确：p中存储a的地址，即p指向a
    *p = 4;//正确：p中存的是a的地址，对a所对应的存储空间存入值4
    p = &b//正确：p可以多次赋值，p存储b的地址
    ```

### 内存分配

- 自上而下为最低内存地址至最高内存地址：

    | 区域 | 存放内容 |
    | :-: | :-: |
    | 保留区 | 系统保留区域 |
    | 程序代码区 | 函数代码块的二进制代码，只读 |
    | 常量区 | 一般常量、字符串常量，只读 |
    | 全局数据区 | 全局变量、静态变量，可读写 |
    | 堆区 | 动态分配的数据 |
    | 未被分配的内存 | 堆的增长区 |
    | 映射区 | 存储动态链接库 |
    | 未被分配的内存 | 栈的增长区 |
    | 栈区 | 局部变量 |
    | 命令行参数区 | 命令行参数和编辑变量 |

#### `C` 中的动态内存分配

- 可以利用四种方法进行动态内存操作：

    1. `void *calloc(int num, int size)`：在内存中动态地分配 `num` 个长度为 `size` 的连续空间，并将每一个字节都初始化为`0`。所以它的结果是分配了 `num * size` 个字节长度的内存空间，并且每个字节的值都是 `0` 。

    2. `void free(void *address)`：该函数释放 `address` 所指向的内存块,释放的是动态分配的内存空间。

    3. `void *malloc(int num)`:在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。

    4. `void *realloc(void address, int newsize)`：该函数重新分配内存，把内存扩展到 `newsize`。

    5. `void *memset(void *s, int ch, size_t n)`：将 `s` 中当前位置后面的 `n` 个字节用 `ch` 替换并返回s。

#### `C++` 中的动态内存分配

- 使用 `new <data_type>` 来在分配内存的同时创建一个对象，使用 `delete <data_name>` 来删除分配的内存。

- 对于内置类型而言，`new` 仅仅是分配内存，除非后面显示加 `()`，相当于调用它的构造函数；对于自定义类型而言，只要一调用 `new`，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化，即使后面没有加 `()`。

### `malloc/free` 与 `new/delete` 的区别

- 相同点：都可用于申请动态内存和释放内存。

- 不同点：

    1. `malloc` 与 `free` 是 `C` 语言的标准库函数，`new/delete` 是 `C++` 的操作符。
    2. `malloc` 需要给定申请内存的大小，返回的指针需要强制转换；`new` 不仅无需指定内存大小并申请一块内存，还会调用类的构造函数生成对象，返回的指针不需要强制转换。
    3. `free` 只是释放一块内存区域，`del` 在释放内存区域的同时还对调用类的析构函数。
    4. `malloc` 失败返回空，`new` 失败抛异常。

### 堆栈的区别

- 分配上的区别
  1. 栈：由操作系统自动分配释放，存放函数的参数值、局部变量的值等。
  2. 堆： 一般由程序员分配释放。若程序员不释放，程序结束时可能由 `OS` 回收，分配方式类似于链表。
- 缓存方式上的区别
  1. 栈：使用一级缓存，通常是被调用时处于存储空间中，调用完毕立即释放。
  2. 堆：使用二级缓存，生命周期由虚拟机的垃圾回收算法来决定，并不是一旦成为孤儿对象后就能被回收。

### 内存泄漏

- 程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，这就是内存泄漏。

## 函数

### 函数参数的压栈顺序

- 从右到左。

### 处理函数返回值

- 在函数返回时会生成一个临时变量来保存返回值结果，把函数返回值的引用作为函数参数传入函数内。

### 回调函数

- 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。
- 简单来说：回调函数是由别人的函数执行时调用你实现的函数。
- 一个回调函数的通俗解释，源于[知乎回答](https://www.zhihu.com/answer/13005983)：你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。

## 面向对象

### 面向对象是什么

- 面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。

### 封装

- 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。

### 抽象

- 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

- 数据抽象有两个重要的优势：

    1. 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。

    2. 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。

- 设计策略：抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。

### 继承

- 继承指的是建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，可以重新定义或加进新数据和函数，从而建立了类的层次或等级。

- 三种继承方式相应地改变了基类成员的访问属性，如下表：

    | 继承方式 | 基类 `public` 成员、`protected` 成员、`private` 成员变化 |
    | :-: | :-: |
    | `public` 继承 | `public, protected, private` |
    | `private` 继承 | `private, private, private` |
    | `protected` 继承 | `protected, protected, private` |

- 子类对父类成员的访问权限跟如何继承没有任何关系，“子类可以访问父类的 `public` 和 `protected` 成员，不可以访问父类的 `private` 成员”——这句话对任何一种继承都是成立的。

- 派生类会继承所有基类方法，但下列情况除外：

    1. 基类的构造函数、析构函数和拷贝构造函数。

    2. 基类的重载赋值运算符。

    3. 基类的友元函数。

- 假设一个类 `C` 分别被类 `A` 和类 `B` 继承，类 `A` 和类 `B` 共同被类 `D` 继承，需要设置类 `A` 和类 `B` 继承方式为虚继承，否则会使 `D` 创建两个对象。

### 多态

- 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
- 多态意味着相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。
- 多态的实现主要分为静态多态和动态多态。

    1. 静态多态主要是重载，在编译的时候就已经确定。两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。

    2. 动态多态是用虚函数机制实现的，在运行期间动态绑定，通过在基类中对函数使用关键字 `virtual` 声明为虚函数来实现。子类继承了父类，父类中的函数是虚函数，在子类中重写了这个虚函数，这种情况会使编译器在处理派生类中重新定义的该函数时不会静态链接到基类的该函数。这种操作称为动态链接，或后期绑定。
- 如果基类中声明虚函数时不进行定义而是进行 `virtual <type> <fun()> = 0` 的操作，这样就会声明为纯虚函数。通常在处理基类中不能对虚函数给出有意义的实现情况时使用。

### 重载

- 友元运算符的参数规则与类成员运算符的参数规则不同，一元运算符必须显式地声明一个参数，二元运算符必须显式地声明两个参数。类成员运算符重载时, 参数中隐含了一 个 `this` 指针.

- 重载运算符不能改变原有运算符的优先级，结合性和操作数个数。

- 重载运算符不能使用缺省参数。

- 除赋值运算符外，重载运算符可由派生类继承下去。

- 运算符 `=、()、[]、->` 可作为类成员运算符，不能作为友员运算符。
- 运算符 `“.”、“::” 、“?:”` 不能重载。

### 抽象类

- 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。

- 设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。

### 对象内存布局

- 最基本的对象内存计算规则：对象的内存大小为成员变量的内存之和，成员函数不占内存，无成员变量的对象大小为 `1` 字节。

- 对于一个只包含非静态成员变量和普通成员函数的类，成员函数放在代码区，该类所有对象公有这一个；成员变量放在堆区，该类对象私有，每新建一个对象都会新建一块内存区域。

- 当有类中有虚函数时，会为该类的每一个实例在堆区（对象内存其实位置）添加一个指向虚函数表的指针。

- 类中的 `static` 成员变量不占用内存该类自身实例化对象的内存。

- 几条关于对象内存大小的总结：

  1. 空类的大小为 `1` 字节。
  2. 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。
  3. 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针，`vptr` 的大小。
  4. 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小。
  5. 虚函数继承，不管是单继承还是多继承，都是继承了基类的`vptr`。

### 构造函数

- 如果的构造函数只有一个参数时，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。

### 析构函数

- 析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

- 类析构顺序：

    1. 派生类本身的析构函数。

    2. 基类析构函数。

### 拷贝构造函数

- 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

    1. 通过使用另一个同类型的对象来初始化新创建的对象。

    2. 复制对象把它作为参数传递给函数。

    3. 复制对象，并从函数返回这个对象。

- 如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

- 拷贝构造函数的形参必须设为常量的引用，否则会引起拷贝构造函数的无限调用。

### 友元函数 & 友元类

- 类的友元函数是定义在类外部，但有权访问类的所有私有（`private`）成员和保护（`protected`）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

- 友元函数没有 `this` 指针，因为友元不是类的成员。只有成员函数才有 `this` 指针。

- 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 `friend`。

- 如果要声明 `B` 类为 `A` 类的右元，即 `B` 的所有成员函数可以访问 `A` 类中的私有成员及保护成员，需要在 `A` 类中声明：

    ```C++
    friend class B
    ```

- 友元关系没有继承性。假如类 `B` 是类 `A` 的友元，类 `C` 继承于类 `A`，那么友元类 `B` 是没办法直接访问类 `C` 的私有或保护成员。
- 友元关系没有传递性。假如类 `B` 是类 `A` 的友元，类 `C` 是类 `B` 的友元，那么友元类 `C` 是没办法直接访问类 `A`的私有或保护成员，也就是不存在“友元的友元”这种关系。

### 内联函数

- 内联函数在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

- 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

- 引入内联函数的目的是为了解决程序中函数调用的效率问题。程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这是以额外空间换取时间上节省。

- 使用内联函数注意三点：

    1. 在内联函数内不允许使用循环语句和开关语句。

    2. 内联函数的定义必须出现在内联函数第一次调用之前。

    3. 类结构中所在的类说明内部定义的函数是内联函数。

### 虚函数

- 虚函数讲解：[知乎文章](https://zhuanlan.zhihu.com/p/28530472)
- 程序通过对象内存最开始位置的虚函数表指针 `vptr` 找到虚函数表 `vtbl`，表中存放着虚函数的指针，通过该指针找到对应虚函数的实现区域并进行调用。
- 构造函数不可以是虚函数，析构函数可以是虚函数且推荐设置为虚函数。具体补充：[CSDN博客](https://blog.csdn.net/sunpengshanda/article/details/80921748)
- 默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型；虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。
- 虚函数可以声明为 `private`, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的 `private` 虚函数。虚函数的重载性和它声明的权限无关。

### 纯虚函数 & 抽象类

- 声明了纯虚函数的类是一个抽象类，无法创建该类的实例，只能创建该类的派生类的实例。其目的在于，使派生类仅仅只是继承函数的接口。
- 抽象类中，成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。
- 如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类；如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。
- 当子类重写父类中的虚函数的时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。
- 纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。

### 类的静态成员

- 类的静态成员变量在类实例化之前就已经存在，并分配了内存，所以即使在类对象不存在的情况下也能被调用。
- 无论创建多少个该类的对象，该类的静态成员都只有一个副本，被类的所有对象共享。
- 类的静态成员不能使用构造函数初始化，而是类的外部通过使用范围解析运算符 `::` 来重新声明静态变量从而对它进行初始化。
- 静态成员函数没有 `this` 指针只能访问静态成员数据、其他静态成员函数和类外部的其他函数，不能直接访问类中说明的非静态成员。
- 可以通过类名访问（无对象生成时亦可），也可以通过对象访问。

### 内存补齐

- 内存补齐讲解：[知乎文章](https://zhuanlan.zhihu.com/p/32261819)

- 内存补齐主要遵循两条基本规则：

    1. 成员变量的偏移量必须为该变量自身大小的整数倍；

    2. 对象内存的大小为最大成员变量大小的整数倍；

- 宏 `#pragma pack (n)` 可以强制设定偏移量为 `n` 或自身内存大小中较小值的整数倍，`n` 为 `1` 时即设置为无内存补齐。

### 类成员函数的前置`const`与后置`const`

- 当 `const` 在函数名前面的时候修饰的是函数返回值，函数返回一个常量值。

- 当 `const` 在函数名后面的输给表示是该类的常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作；对于该类的 `const` 的对象，不能引用非 `const` 的成员函数（只能引用后置 `const` 修饰的常成员函数）。

## 关键字与内置函数

### `NULL` 和 `nullptr`

- 在编译时 NULL 会被解释为 0 ，而 `nullptr` 就代表空指针。

### `delete[]` 和 `delete`

- 区别讲解：[CSDN文章](https://blog.csdn.net/u012936940/article/details/80919880)

- 概括的为：对于基本数据类型（如 `int`）二者无差别，对于自定义类型（通常指类）如果是 `new` 申请的内存，释放时用 `delete`；如果是使用 `new []` 申请的内存，释放时要用 `delete []`。

### `[xx]_ptr`  智能指针

#### `auto_ptr`

- 采用所有权模式，存在潜在的内存崩溃问题，于 `C++11` 中被抛弃。例如如下代码：

    ```C++
    auto_ptr<string> p1 (new string ("Hello"));
    auto_ptr<string> p2;
    p2 = p1; //auto_ptr不会报错
    ```

    当程序运行时访问 `p1` 将会报错，因为 `p2` 剥夺了 `p1` 的所有权。

#### `unique_ptr`

- 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象，同时还有更智能的功能，比 `auto_ptr` 更安全，替代了 `auto_ptr`。针对于代码：

    ```C++
    uqinue_ptr<string> p1(new string ("Hello"));
    unique_ptr<string> p2;
    p2 = p1; //报错！避免p3不再指向有效数据的问题
    p2 = move(p1); // 正确！
    p3 = unique_ptr<string>(new string ("World")); // 正确！右值为临时值。
    ```

#### `shared_ptr`

- 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。它使用计数机制来表明资源被几个指针共享，当计数等于 `0` 时，资源会被释放。

#### `weak_ptr`

- `weak_ptr` 是一种不控制对象生命周期的智能指针, 它指向一个 `shared_ptr` 管理的对象. 进行该对象的内存管理的是那个强引用的 `shared_ptr`。 `weak_ptr` 只是提供了对管理对象的一个访问手段。`weak_ptr` 设计的目的是为配合 `shared_ptr` 而引入的一种智能指针来协助 `shared_ptr` 工作, 它只可以从一个 `shared_ptr` 或另一个 `weak_ptr` 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

### `[xx]_cast` 四种类型转换

- 讲解：[简书文章](https://www.jianshu.com/p/5163a2678171)

#### `static_cast`

- 主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：

    1. 用于类层次结构中，基类和子类之间指针和引用的转换；

        当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；

        当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；

    2. 用于基本数据类型之间的转换，如把 `int` 转换成 `char`，把 `int` 转换成`enum` 等等，这种转换的安全性需要程序员来保证；

    3. 把 `void` 指针转换成目标类型的指针，是及其不安全的；

- `static_cast` 不能转换掉 `expression` 的 `const`、`volatile` 和`__unaligned` 属性。

#### `const_cast`

- 用于将 `const` 属性转为非 `const` 属性。

#### `dynamic_cast`

- `dynamic_cast` 主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换，只能用于含有虚函数的类间的转换，且只能转换为类的指针、类的引用或是 `void*`。

- 在类层次间进行上行转换时，与 `static_cast` 效果一样；在进行类层次间的下行转换时，会检查基类的指针是否真正的指向一个子类类型的对象，如果是则能进行正确的转换，否则会返回 `NULL`，如果是引用则会在运行时抛出异常。一段应用代码：

    ```C++
    //定义
    class Widget{};
    class SpecialWidget:public Widget{};
    void update(SpecialWidget  *psw);

    Widget * pw;

    //如果pw所指的是SpecialWidget ，那么就传递过去；如果pw指的是Widget ，
    //那么传递过去的值是null
    update(dynamic_cast<SpecialWidget *> (pw));
    ```

#### `reinterpret_cast`

- 几乎什么都可以转，故可能会出问题，尽量少用。

### `extern "C"`

- 用于 `C++` 链接在 `C` 语言模块中定义的函数。

- 使用方法示例：

  - C++调用C函数

  ```c++
  //xx.h
  extern int add(...)

  //xx.c
  int add(){ }

  //xx.cpp
  extern "C" {
      #include "xx.h"
  }
  ```

  - C调用C++函数

  ```c++
  //xx.h
  extern "C"{
      int add();
  }
  //xx.cpp
  int add(){ }

  //xx.c
  extern int add();
  ```

### `using`

- 关于 `using` 的几种用法（局部与全局 `using`、改变访问性、函数重载、取代typedef等）介绍：[开源项目](https://light-city.club/sc/basic_content/using/)

### `::`

- 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间。
- 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的。
- 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的。

### `struct`

- 在 `C` 和 `C++` 中的区别

|                           C                            |                             C++                              |
| :----------------------------------------------------: | :----------------------------------------------------------: |
|                 只能放数据，不能放函数                 |                       可以放数据和函数                       |
|                   不能使用访问修饰符                   |          可以使用 `public`、`protected`、`private`           |
|                  定义时必须加`struct`                  |                    定义时可以不加`struct`                    |
|                     没有继承的概念                     |                           可以继承                           |
| 若结构体的名字与函数名相同，可以正常运行且正常的调用！ | 若结构体的名字与函数名相同，使用结构体，只能使用带 `struct` 定义！ |

- `struct` 通常作为数据结构的实现体，它默认的数据访问控制是 `public` 的；`class` 通常作为对象的实现体，它默认的成员变量访问控制是 `private` 的。

### `union`

- 一个 `union` 可以有多个数据成员，在任意时刻只有一个数据成员可以有值,当某个成员被赋值后其他成员变为未定义状态。特点：
  1. 默认访问控制符为 `public`。
  2. 可以含有构造函数、析构函数。
  3. 不能含有引用类型的成员。
  4. 不能继承自其他类，不能作为基类。
  5. 不能含有虚函数。
  6. 匿名 `union` 在定义所在作用域可直接访问 `union` 成员。
  7. 匿名 `union` 不能包含 `protected` 成员或 `private` 成员。
  8. 全局匿名联合必须是静态的。

### `const`

- `const` 修饰类的成员变量，表示成员常量，不能被修改。
- 后置 `const` 修饰类的成员函数承诺在本函数内部不会修改类内的数据成员，不会调用其他非 `const` 成员函数。
- `const` 函数只能调用 `const` 的函数，非 `const` 函数可以调用任意的成员函数。
- 如果 `const` 构成了函数重载，`const` 对象只能调用 `const` 的函数，非 `const` 对象优先调用非 `const` 函数。
- 在类体外定义的 `const` 成员函数，在定义和声明处都需要 `const` 修饰符。
- 对于非内部数据类型的输入参数，应该将“值传递”的方式改为“`const` 引用传递”，目的是提高效率；对于内部数据类型的输入参数，不要将“值传递”的方式改为“`const` 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。
- `const` 与 `#define` 的区别：`const` 常量具有类型，编译器可以进行安全检查，在程序运行过程中只有一份拷贝；`#define` 宏定义没有数据类型，只是简单的字符串替换，不能进行安全检查，在内存中有若干个拷贝。
- 关于 `const` 的指针应用：如果 `const` 位于 `*` 的左侧，则 `const` 就是用来修饰指针所指向的变量，即指针指向为常量；如果 `const` 位于 `*` 的右侧，`const` 就是修饰指针本身，即指针本身是常量。

    ```c++
    const char * a; //指向const对象的指针或者说指向常量的指针。
    char const * a; //同上
    char * const a; //指向类型对象的const指针。或者说常指针、const指针。
    const char * const a; //指向const对象的const指针。
    ```

 1. 指向常量的指针

    - 对于指向常量的指针，不能通过指针来修改对象的值，也不能使用 `void *` 指针保存 `const` 对象的地址，必须使用 `const`   `void *` 类型的指针保存 `const` 对象的地址。

    - 允许把非 `const` 对象的地址赋值给 `const` 对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。

 2. 常指针

    - 常指针的值必须初始化，且不可修改。
    - 常指针在初始化时不能用常量地址进行赋值，因为指针本身指向的是一个变量。

### `enum class`

- 枚举类的用法示例：

  ```c++
  enum class Color2
  {
      RED=2,
      YELLOW,
      BLUE
  };

  enum class Color3:char;  // 前向声明
  enum class Color3:char // 定义
  {
      RED='r',
      BLUE
  };

  int main()
  {
      Color2 c2 = Color2::RED;
      cout << static_cast<int>(c2) << endl;

      char c3 = static_cast<char>(Color3::RED);
      cout<< c3 <<endl;
      return 0;
  }
  ```

### `static`

- 当函数中的变量声明为 `static` 时，空间将在程序的生命周期内分配，在执行此函数时进行初始化。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。因此，使用 `static` 修饰局部变量可以在函数调用之间保持局部变量的值。
- `static` 修饰符可以应用于全局变量。当 `static` 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 `static` 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 `static` 变量或方法同一个文件中。
- 在函数返回类型前加 `static`，函数就定义为静态函数，这个函数只可在本 `cpp` 内使用，不会同其他 `cpp` 中的同名函数引起冲突。函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

### `extern`

- `extern` 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 `extern` 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
- 当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 `extern` 来得到已定义的变量或函数的引用。可以这么理解，`extern` 是用来在另一个文件中声明一个全局变量或函数。
- `extern` 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。

### `this`

- 一个对象的 `this` 指针并不是对象本身的一部分，不会影响 `sizeof(对象)`的结果。

- `this` 作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上 `this` 指针，编译器在编译的时候也是加上 `this` 的，它作为非静态成员函数的隐含形参，对各成员的访问均通过 `this` 进行。

- `this` 在成员函数的开始执行前构造，在成员函数的执行结束后清除。

- 两种用处：

  1. 在类的非静态成员函数中返回类对象本身的时候，直接使用 `return *this`。
  2. 当参数与成员变量名相同时，如 `this->n = n` (不能写成 `n = n` )。

### `explicit`

- 修饰一个参数的类构造函数时，可以防止隐式转换和复制初始化，禁止编译器执行非预期（往往也不被期望）的类型转换。
- 如果类构造函数参数大于或等于两个时，是不会产生隐式转换的，此时 `explicit` 关键字无效。
- 如果除了第一个参数以外的其他参数都有默认值的时候，`explicit` 关键字依然有效。这种情况下调用构造函数时只传入一个参数，等效于只有一个参数的类构造函数。

### `inline`

- 类中定义了的函数是隐式内联函数，类中仅声明的函数须在实现处(定义处)加 `inline` 关键字才能称为内联函数。
- 编译器对 `inline` 函数的处理步骤 ：
  1. 将 `inline` 函数体复制到 `inline` 函数调用点处；
  2. 为所用 `inline` 函数中的局部变量分配内存空间；
  3. 将 `inline` 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
  4. 如果 `inline` 函数有多个返回点，将其转变为 `inline` 函数代码块末尾的分支（使用 `GOTO`）。

### `volatile`

- `volatile` 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 `volatile` 告诉编译器不应对这样的对象进行优化。
- `volatile` 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 `volatile` 修饰的变量，可能由于编译器的优化，从 `CPU` 寄存器中取值）。
- `const` 可以是 `volatile` （如只读的状态寄存器）。
- 指针可以是 `volatile。`

### `stdout` & `stderr`

- `stdout & stderr` 默认均为向屏幕输出。

- 当输出重定向至磁盘文件时，`stdout` 可以重定向到磁盘文件存储而 `stderr` 不行。

- 对于 `Linux` 环境下（**未测验，据网上讲解**）:

    1. `stdout`（标准输出），输出方式是行缓冲。输出的字符会先存放在缓冲区，等按下回车键时才进行实际的 `I/O` 操作。

    2. `stderr`（标准错误），是不带缓冲的，这使得出错信息可以直接尽快地显示出来。

- 对于 `Windows` 环境下（**已编写程序测验**）：

    `stdout` 和 `stderr` 均直接输出，即 `stdout` 不碰到回车符也会输出。

### `size_t`

- `size_t` 通常被用于数组索引和循环计数。使用其它类型来进行数组索引操作的程序可能会在某些情况下出错。

### `sizeof()`

- 对于一个空类型/只有构造函数和析构函数的类型，占用多少内存（对类求 `sizeof()` 的结果）由编译器决定（`VS` 中为 `1`）。
- 对于一个数组，`sizeof` 求整个数组的大小。

### `decltype (expression)`

- 作用：查询表达式的类型并返回。
- 用法讲述：[开源项目](https://light-city.club/sc/basic_content/decltype/)

### `assert(int expression)`

- `assert` 的作用是先计算表达式 `expression`，如果其值为假（即为`0`）那么它先向 `stderr` 打印一条出错信息,然后通过调用 `abort` 来终止程序运行。
- 使用 `assert` 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。

## 其它

### 预处理

- `ANSI C`预定义了一些宏可以直接使用但不可以修改，包括：

  1. `__DATE__`：当前日期，一个以 `"MMM DD YYYY"` 格式表示的字符常量。

  2. `__TIME__`：当前时间，一个以 `"HH:MM:SS"` 格式表示的字符常量。

  3. `__FILE__`：这会包含当前文件名，一个字符串常量。

  4. `__LINE__`：这会包含当前行号，一个十进制常量。

  5. `__STDC__`：当编译器以 `ANSI` 标准编译时，则定义为 `1`。

- 预处理器运算符

  1. 宏延续运算符（`\`）：一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（`\`）。

  2. 字符串常量化运算符（`#`）：在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（`#`）。在宏中使用的该运算符有一个特定的参数或参数列表。

  3. 标记粘贴运算符（`##`）：宏定义内的标记粘贴运算符（`##`）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。

  4. `defined()` 运算符：预处理器 `defined` 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 `#define` 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。

### 异常处理

- 异常是程序在执行期间产生的问题。`C++` 异常处理涉及到三个关键字：

1. `throw`: 当问题出现时，程序会抛出一个异常。这是通过使用 `throw` 关键字来完成的。

2. `catch`: 在想要处理问题的地方，通过异常处理程序捕获异常。`catch` 关键字用于捕获异常。

3. `try`: `try` 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 `catch` 块。

### 深拷贝与浅拷贝

- 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
- 浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用 `std::shared_ptr`，可以完美解决这个问题。

## `STL`

### 迭代器

- 迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

### `vector`

- 底层基于数组实现，包含三个迭代器，`start` 和 `finish`之间是已经被使用的空间范围，`end_of_storage `是整块连续空间包括备用空间的尾部。

- 拥有一段连续的内存空间，支持随机访问且随机访问性能好，插入删除性能差，一次性分配好内存，不够时才进行扩容。

- `vector`每次扩充容量时，新的容量都是前一次的两倍（这样可以保证常数时间的时间复杂度）。把之前的数据复制到新的数组中，再释放之前的内存（在时间性能有负面影响）。

- 删除所有数据时（`free` 函数），空间不释放。

- 1. `reserve` 是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化`push_back`），可以提高效率，其次还可以减少多次要拷贝数据的问题。`reserve` 只是保证 `vector` 中的空间大小（`capacity`）最少 达到参数所指定的大小  `n`。`reserve` 只有一个参数。

  2. `resize` 可以改变有效空间的大小，也有改变默认值的功能。`capacity` 的大小也会随着改变。`resize` 可以有多个参数。

- 1. `size` 表示当前 `vector` 中有多少个元素`（finish - start）`。
  2. `capacity`表示它已经分配的内存中可以容纳多少元素`（end_of_storage - start）`。


### `List`

- 底层基于双向链表实现。

- 占用内存不连续，不支持随机访问，插入删除性能好，每次插入新节点都会进行内存申请。

### `set`

- 底层基于红黑树实现，适用于有序不重复集合。

### `map`

- 底层基于红黑树实现，适用于不重复映射的有序键值对。

### `unordered_map`

- 底层基于哈希表实现，无序。

## 内容补充

- [计算机网络基础](https://zhuanlan.zhihu.com/p/84316213)
- [数据库](https://blog.csdn.net/qq_36982160/article/details/89258056)
